/*
 * Copyright (C) 2016 Lightbend Inc. <http://www.lightbend.com>
 */
package akka.stream.contrib.amqp

import akka.NotUsed
import akka.stream._
import akka.stream.scaladsl.Source
import akka.stream.stage._
import akka.util.ByteString
import com.rabbitmq.client.AMQP.BasicProperties
import com.rabbitmq.client._

import scala.collection.mutable

final case class IncomingMessage(bytes: ByteString, envelope: Envelope, properties: BasicProperties)

object AmqpSource {
  /**
   * Scala API:
   */
  def apply(settings: AmqpSourceSettings, bufferSize: Int): Source[IncomingMessage, NotUsed] =
    Source.fromGraph(new AmqpSource(settings, bufferSize))

  /**
   * Java API:
   */
  def create(settings: AmqpSourceSettings, bufferSize: Int): akka.stream.javadsl.Source[IncomingMessage, NotUsed] =
    akka.stream.javadsl.Source.fromGraph(new AmqpSource(settings, bufferSize))

  private val defaultAttributes = Attributes.name("AmqpSource")

}

/**
 * Connects to an amqp server upon materialization and consumes messages from it emitting them
 * into the stream. Each materialized stage will create one connection to the broker.
 * As soon as an `IncomingMessage` is sent downstream, an ack for it is sent to the broker.
 *
 * @param bufferSize The max number of elements to prefetch and buffer at any given time.
 */
final class AmqpSource(settings: AmqpSourceSettings, bufferSize: Int) extends GraphStage[SourceShape[IncomingMessage]] with AmqpConnector { stage =>

  val out = Outlet[IncomingMessage]("AmqpSource.out")

  override val shape: SourceShape[IncomingMessage] = SourceShape.of(out)

  override protected def initialAttributes: Attributes = AmqpSource.defaultAttributes

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic = new GraphStageLogic(shape) with AmqpConnectorLogic {

    override val settings = stage.settings
    override def connectionFactoryFrom(settings: AmqpConnectionSettings) = stage.connectionFactoryFrom(settings)

    private val queue = mutable.Queue[IncomingMessage]()

    override def whenConnected(): Unit = {
      import scala.collection.JavaConverters._
      // we have only one consumer per connection so global is ok
      channel.basicQos(bufferSize, true)
      val consumerCallback = getAsyncCallback(handleDelivery)
      val shutdownCallback = getAsyncCallback[Option[ShutdownSignalException]] {
        case Some(ex) => failStage(ex)
        case None     => completeStage()
      }

      val amqpSourceConsumer = new DefaultConsumer(channel) {
        override def handleDelivery(consumerTag: String, envelope: Envelope, properties: BasicProperties, body: Array[Byte]): Unit = {
          consumerCallback.invoke(IncomingMessage(ByteString(body), envelope, properties))
        }

        override def handleCancel(consumerTag: String): Unit = {
          // non consumer initiated cancel, for example happens when the queue has been deleted.
          shutdownCallback.invoke(None)
        }

        override def handleShutdownSignal(consumerTag: String, sig: ShutdownSignalException): Unit = {
          // "Called when either the channel or the underlying connection has been shut down."
          shutdownCallback.invoke(Option(sig))
        }
      }

      def setupNamedQueue(settings: NamedQueueSourceSettings): Unit = {
        channel.basicConsume(
          settings.queue,
          false, // never auto-ack
          settings.consumerTag, // consumer tag
          settings.noLocal,
          settings.exclusive,
          settings.arguments.asJava,
          amqpSourceConsumer
        )
      }

      def setupTemporaryQueue(settings: TemporaryQueueSourceSettings): Unit = {
        // this is a weird case that required dynamic declaration, the queue name is not known
        // up front, it is only useful for sources, so that's why it's not placed in the AmqpConnectorLogic
        val queueName = channel.queueDeclare().getQueue
        channel.queueBind(queueName, settings.exchange, settings.routingKey.getOrElse(""))
        channel.basicConsume(
          queueName,
          amqpSourceConsumer
        )
      }

      settings match {
        case settings: NamedQueueSourceSettings     => setupNamedQueue(settings)
        case settings: TemporaryQueueSourceSettings => setupTemporaryQueue(settings)
      }

    }

    def handleDelivery(message: IncomingMessage): Unit = {
      if (isAvailable(out)) {
        pushAndAckMessage(message)
      } else {
        if (queue.size + 1 > bufferSize) {
          failStage(new RuntimeException(s"Reached maximum buffer size $bufferSize"))
        } else {
          queue.enqueue(message)
        }
      }
    }

    setHandler(out, new OutHandler {
      override def onPull(): Unit = {
        if (queue.nonEmpty) {
          pushAndAckMessage(queue.dequeue())
        }
      }

    })

    def pushAndAckMessage(message: IncomingMessage): Unit = {
      push(out, message)
      // ack it as soon as we have passed it downstream
      // TODO ack less often and do batch acks with multiple = true would probably be more performant
      channel.basicAck(
        message.envelope.getDeliveryTag,
        false // just this single message
      )
    }

  }

}
